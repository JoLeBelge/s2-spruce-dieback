# librairie pour effectuer des requêtes sur un webserver
require(curl)
# librairie pour la lecture de shapefile
library(sf)
server.api <- "http://forestimator.gembloux.ulg.ac.be/api/"
shp.path <- "/home/jo/Documents/carteApt/autres/shpTest/epioux_sample.shp"
parcellaire.shp <- st_read(shp.path)
polNum <- 1
cat(paste0("traitement du polygone numéro ", polNum,"\n"))
wkt.pt <- st_as_text( st_centroid(parcellaire.shp$geometry[polNum])
#cat(paste0("wkt polygone : \n ", wkt.pol,"\n"))
my.request <- paste0(server.api,"dendro2018/polygon/",wkt.pol)
# remplacement des espaces par le symbole consacré
my.request <- gsub(" ", "%20", my.request, fixed = TRUE)
# on effectue la requete auprès du serveur - résultat sauvé en mémoire sous forme hexadécimale (=raw)
req.res <- curl_fetch_memory(my.request)
# on écrit dans la console (ou ailleurs) la réponse du serveur
cat(rawToChar(req.res$content))
cat("\n")
}
wkt.pt <- st_as_text( st_centroid(parcellaire.shp$geometry[polNum]))
wkt.pt
layer<-"ZBIO"
my.request <- paste0(server.api,layer,"/point/",wkt.pt)
# remplacement des espaces par le symbole consacré
my.request <- gsub(" ", "%20", my.request, fixed = TRUE)
# on effectue la requete auprès du serveur - résultat sauvé en mémoire sous forme hexadécimale (=raw)
req.res <- curl_fetch_memory(my.request)
# on écrit dans la console (ou ailleurs) la réponse du serveur
cat(rawToChar(req.res$content))
cat("\n")
wkt.pt
my.request <- paste0(server.api,layer,"/args/txt/point/",wkt.pt) # args/txt c'est pour avoir la réponse sous forme de texte plutôt que la valeur du pixel (nombre entier) par défaut
# remplacement des espaces par le symbole consacré
my.request <- gsub(" ", "%20", my.request, fixed = TRUE)
my.request
server.api <- "http://http://localhost:8085/api/"
my.request <- paste0(server.api,layer,"/args/txt/point/",wkt.pt) # args/txt c'est pour avoir la réponse sous forme de texte plutôt que la valeur du pixel (nombre entier) par défaut
# remplacement des espaces par le symbole consacré
my.request <- gsub(" ", "%20", my.request, fixed = TRUE)
my.request
server.api <- "http://localhost:8085/api/"
my.request <- paste0(server.api,layer,"/args/txt/point/",wkt.pt) # args/txt c'est pour avoir la réponse sous forme de texte plutôt que la valeur du pixel (nombre entier) par défaut
# remplacement des espaces par le symbole consacré
my.request <- gsub(" ", "%20", my.request, fixed = TRUE)
# on effectue la requete auprès du serveur - résultat sauvé en mémoire sous forme hexadécimale (=raw)
req.res <- curl_fetch_memory(my.request)
# on écrit dans la console (ou ailleurs) la réponse du serveur
cat(rawToChar(req.res$content))
cat("\n")
for (layer in c("ZBIO", "MNT", "SS","TOPO")){
my.request <- paste0(server.api,layer,"/args/txt/point/",wkt.pt) # args/txt c'est pour avoir la réponse sous forme de texte plutôt que la valeur du pixel (nombre entier) par défaut
# remplacement des espaces par le symbole consacré
my.request <- gsub(" ", "%20", my.request, fixed = TRUE)
# on effectue la requete auprès du serveur - résultat sauvé en mémoire sous forme hexadécimale (=raw)
req.res <- curl_fetch_memory(my.request)
# on écrit dans la console (ou ailleurs) la réponse du serveur
cat(paste0("couche ", layer " :"))
cat(rawToChar(req.res$content))
cat("\n")
}
for (layer in c("ZBIO", "MNT", "SS","TOPO")){
my.request <- paste0(server.api,layer,"/args/txt/point/",wkt.pt) # args/txt c'est pour avoir la réponse sous forme de texte plutôt que la valeur du pixel (nombre entier) par défaut
# remplacement des espaces par le symbole consacré
my.request <- gsub(" ", "%20", my.request, fixed = TRUE)
# on effectue la requete auprès du serveur - résultat sauvé en mémoire sous forme hexadécimale (=raw)
req.res <- curl_fetch_memory(my.request)
# on écrit dans la console (ou ailleurs) la réponse du serveur
cat(paste0("couche ", layer " :"))
cat(rawToChar(req.res$content))
cat("\n")
}
my.request <- paste0(server.api,layer,"/args/txt/point/",wkt.pt) # args/txt c'est pour avoir la réponse sous forme de texte plutôt que la valeur du pixel (nombre entier) par défaut
# remplacement des espaces par le symbole consacré
my.request <- gsub(" ", "%20", my.request, fixed = TRUE)
# on effectue la requete auprès du serveur - résultat sauvé en mémoire sous forme hexadécimale (=raw)
req.res <- curl_fetch_memory(my.request)
# on écrit dans la console (ou ailleurs) la réponse du serveur
cat(paste0("couche ", layer " :"))
for (layer in c("ZBIO", "MNT", "SS","TOPO")){
my.request <- paste0(server.api,layer,"/args/txt/point/",wkt.pt) # args/txt c'est pour avoir la réponse sous forme de texte plutôt que la valeur du pixel (nombre entier) par défaut
# remplacement des espaces par le symbole consacré
my.request <- gsub(" ", "%20", my.request, fixed = TRUE)
# on effectue la requete auprès du serveur - résultat sauvé en mémoire sous forme hexadécimale (=raw)
req.res <- curl_fetch_memory(my.request)
# on écrit dans la console (ou ailleurs) la réponse du serveur
cat(paste0("couche ", layer, " :"))
cat(rawToChar(req.res$content))
cat("\n")
}
layer <- "Topo"
my.request <- paste0(server.api,layer,"/args/txt/point/",wkt.pt) # args/txt c'est pour avoir la réponse sous forme de texte plutôt que la valeur du pixel (nombre entier) par défaut
# remplacement des espaces par le symbole consacré
my.request <- gsub(" ", "%20", my.request, fixed = TRUE)
# on effectue la requete auprès du serveur - résultat sauvé en mémoire sous forme hexadécimale (=raw)
req.res <- curl_fetch_memory(my.request)
# on écrit dans la console (ou ailleurs) la réponse du serveur
cat(paste0("couche ", layer, " :"))
cat(rawToChar(req.res$content))
cat("\n")
for (layer in c("ZBIO", "MNT", "SS","Topo")){
my.request <- paste0(server.api,layer,"/args/txt/point/",wkt.pt) # args/txt c'est pour avoir la réponse sous forme de texte plutôt que la valeur du pixel (nombre entier) par défaut
# remplacement des espaces par le symbole consacré
my.request <- gsub(" ", "%20", my.request, fixed = TRUE)
# on effectue la requete auprès du serveur - résultat sauvé en mémoire sous forme hexadécimale (=raw)
req.res <- curl_fetch_memory(my.request)
# on écrit dans la console (ou ailleurs) la réponse du serveur
cat(paste0("couche ", layer, " : "))
cat(rawToChar(req.res$content))
cat("\n")
}
#server.api <- "http://localhost:8085/api/"
server.api <- "http://forestimator.gembloux.ulg.ac.be/api/"
shp.path <- "/home/jo/Documents/carteApt/autres/shpTest/epioux_sample.shp"
parcellaire.shp <- st_read(shp.path)
# attention, la méthode fonctionne pour des POLYGONES et des MULTIPOLYGONES dont la géométrie est valide. Si géométrie pas valide, je ne garanti pas l'exactitude du résultat.
# boucle sur les polygones du shapefile
for (polNum in 1:nrow(parcellaire.shp)){
cat(paste0("traitement du polygone numéro ", polNum,"\n"))
wkt.pt <- st_as_text( st_centroid(parcellaire.shp$geometry[polNum]))
#cat(paste0("wkt polygone : \n ", wkt.pol,"\n"))
#zone bioclimatique, altitude, sous-secteur radiatif, et situation topographique pour chaque centroïde
for (layer in c("ZBIO", "MNT", "SS","Topo")){
my.request <- paste0(server.api,layer,"/args/txt/point/",wkt.pt) # args/txt c'est pour avoir la réponse sous forme de texte plutôt que la valeur du pixel (nombre entier) par défaut - à toi de voir..
# remplacement des espaces par le symbole consacré
my.request <- gsub(" ", "%20", my.request, fixed = TRUE)
# on effectue la requete auprès du serveur - résultat sauvé en mémoire sous forme hexadécimale (=raw)
req.res <- curl_fetch_memory(my.request)
# on écrit dans la console (ou ailleurs) la réponse du serveur
cat(paste0("couche ", layer, " : "))
cat(rawToChar(req.res$content))
cat("\n")
}
cat("\n\n")
}
install.packages(“httr”)
install.packages("httr")
798-355
826-238
# librairie pour effectuer des requêtes sur un webserver
require(curl)
# librairie pour la lecture de shapefile
library(sf)
# librairie pour la lecture de shapefile
library(sf)
server.api <- "http://forestimator.gembloux.ulg.ac.be/api/"
server.api <- "http://forestimator.gembloux.ulg.ac.be/api/"
shp.path <- "/home/jo/Documents/carteApt/autres/shpTest/epioux_sample.shp"
parcellaire.shp <- st_read(shp.path)
plot(parcellaire.shp)
str(parcellaire.shp)
parcellaire.shp$OBJECTID
str(parcellaire.shp$OBJECTID)
polNum <- 1
cat(paste0("traitement du polygone numéro ", polNum,"\n"))
cat(paste("toto", "tata"))
cat(paste("toto", "tata", sep="///"))
cat(paste("toto", "tata", polNum, sep="///"))
str(parcellaire.shp$geometry)
str(parcellaire.shp$geometry)[2]
parcellaire.shp$geometry[2]
parcellaire.shp$geometry[polNum]
parcellaire.shp$geometry[2]
st_as_text(parcellaire.shp$geometry[polNum])
wkt.pol <- st_as_text(parcellaire.shp$geometry[polNum])
wkt.pol
#cat(paste0("wkt polygone : \n ", wkt.pol,"\n"))
my.request <- paste0(server.api,"dendro2018/polygon/",wkt.pol)
my.request
# remplacement des espaces par le symbole consacré
my.request <- gsub(" ", "%20", my.request, fixed = TRUE)
my.request
# on effectue la requete auprès du serveur - résultat sauvé en mémoire sous forme hexadécimale (=raw)
req.res <- curl_fetch_memory(my.request)
req.res
# on écrit dans la console (ou ailleurs) la réponse du serveur
response.txt <- rawToChar(req.res$content)
response.txt
require(DescTools)
TextToTable(response.txt)
TextToTable(response.txt, sep=";")
TextToTable(response.txt, sep=";", header=T)
t <- TextToTable(response.txt, sep=";", header=T)
t
1:nrow(parcellaire.shp)
setwd("/home/jo/app/s2/articleSco/images/climat")
d <- read.table("growing_seasing_r_t_30")
d <- read.table("growing_seasing_r_t_30.csv")
